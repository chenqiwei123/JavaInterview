### JVM垃圾回收机制

**JVM垃圾回收机制**
> 垃圾回收机制负责清除Java堆中不再使用的对象。
> 
> 程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。

#### 判断一个对象是否可被回收的算法

##### 引用计数算法
>给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。
> 
> 引用计数为 0 的对象可被回收。两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。
> 
> 正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。

```java
public class ReferenceCountingGC {

    public Object instance = null;

    public static void main(String[] args) {
        ReferenceCountingGC objectA = new ReferenceCountingGC();
        ReferenceCountingGC objectB = new ReferenceCountingGC();
        objectA.instance = objectB;
        objectB.instance = objectA;
    }
}
```
##### 可达性分析算法
> 通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。

![img_13.png](Image%2Fimg_13.png)

Java 虚拟机使用该算法来判断对象是否可被回收，在 Java 中 GC Roots 一般包含以下内容:

- 虚拟机栈中引用的对象
- 本地方法栈中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中的常量引用的对象

 
##### 方法区的回收

因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，因此在方法区上进行回收性价比不高。
主要是对常量池的回收和对类的卸载。在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。
类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载:

- 该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。
- 加载该类的 ClassLoader 已经被回收。
- 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。

可以通过 -Xnoclassgc 参数来控制是否对类进行卸载。

##### 标记清除垃圾回收算法
> 标记清除算法是最基础的垃圾回收算法，它分为两个阶段，标记和清除。
> 
> 首先标将存活的对象进行标记，然后清理掉未被标记的对象。
> 
> 标记和清除的过程，需要暂停所有线程，直到完成。

**标记 - 清除：**

将存活的对象进行标记，然后清理掉未被标记的对象。
![img_14.png](Image%2Fimg_14.png)

**标记 - 整理：**

标记完成后，将所有存活的对象向一端移动，然后清理掉边界外的对象。
![img_15.png](Image%2Fimg_15.png)
