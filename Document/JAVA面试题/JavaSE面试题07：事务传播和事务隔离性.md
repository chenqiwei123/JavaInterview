### Spring中支持的常用数据库事务传播属性和事务隔离级别

#### 1 事务的传播行为
**1.1 简介**
> 当事务方法被另一个事务方法调用时，必须指定事务应该如何传播，列如方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行，事务传播的行为有传播属性指定，Spring定义了7中类传播行为

|传播属性| 描述                                                       |
|----|----------------------------------------------------------|
|REQUIRED| **(默认)** 如果有事务在运行，当前的方法就在这个事务内运行，否则就启动一个新的事务，并在自己的事务内运行  |
|REQUIRED_NEW| **(常用)** 当前方法必须启动事务，并在它自己的事务内运行，如果有事务正在运行，应该将他挂起         |
|SUPPORTS| 	如果有事务在运行，当前的方法就在这个事务内运行，否则他可以不运行在事务中                    |
|NOT_SUPPORTE| 	当前的方法不应该运行在事务中，如果有运行的事务，将他挂起                            |
|MANDATORY| 	当前的方法必须运行在事务内部，如果没有正在运行的事务，就抛出异常                        |
|NEVER| 	当前方法不应该运行在事务中，如果有运行的事务，就抛出异常                            |
|NESTED| 	如果有事务在运行，当前的方法就应该在这个事物的嵌套事务内运行，否则，就启动一个新的事务，并在它自己的事务内运行 |

**事务传播属性可以在@Transactional注解的propagation属性中定义**

**2 事务隔离级别**

2.1 数据库事务并发问题
​ 假设现在有两个事务：Transaction01和Transaction02并发执行。

**1) 脏读**
> ①Transaction01将某条记录的AGE值从20修改为30。
> 
> ②Transaction02读取了Transaction01更新后的值：30。
> 
> ③Transaction01回滚，AGE值恢复到了20。
> 
> ④Transaction02读取到的30就是一个无效的值。

**2) 不可重复读**

> ①Transaction01读取了AGE值为20。
>
> ②Transaction02将AGE值修改为30。
>
> ③Transaction01再次读取AGE值为30，和第一次读取不一致。

**3) 幻读**
> ①Transaction01读取了STUDENT表中的一部分数据。
> 
> ②Transaction02向STUDENT表中插入了新的行。
> 
>③Transaction01读取了STUDENT表时，多出了一些行。

**2.2 隔离级别**
> 数据库系统必须具有隔离并发运行各个事务的能力，使它们不会相互影响，避免各种并发问题。一个事务与其他事务隔离的程度称为隔离级别。SQL标准中规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱。

- **读未提交**：READ UNCOMMITTED
允许`Transaction01`读取`Transaction02`未提交的修改。
![img_5.png](Image%2Fimg_5.png)
- **读已提交(Oracle默认隔离级别)**：READ COMMITTED
​ 要求Transaction01只能读取`Transaction02`已提交的修改。
![img_6.png](Image%2Fimg_6.png)
如上图所示，在事务进行读写的时候，加入了锁（读锁和写锁，锁的相容性矩阵），这样在`Transaction01`进行修改的时候，加入了写锁（排他锁）直到事务提交释放锁，这样就保证了`Transaction02`就无法读取该值，解决了脏读的问题。
- ![img_7.png](Image%2Fimg_7.png)
  但是读已提交仍然会存在不可重复读的问题，如上图所示。使得`Transaction02` 前后两次读取的同一变量的值不一样。那怎么办呢，就到我们不可重复读的情况。
- **可重复读(MySQL的默认事务隔离级别)**：REPEATABLE READ
​ 确保Transaction01可以多次从一个字段中读取到相同的值，即Transaction01执行期间禁止其它事务对这个字段进行更新。也就是简单点说，操作读完提交事务才释放锁，而不是一读完就释放锁。
  MySQL会利用MVCC机制让其读到更新之前的值，也就第一次读到的值。即使事务巍提交之前，有另外的事务将其值修改，也是读到旧值。
![img_8.png](Image%2Fimg_8.png)
- **可串行化**：SERIALIZABLE
​ 确保Transaction01可以多次从一个表中读取到相同的行，在Transaction01执行期间，禁止其它事务对这个表进行添加、更新、删除操作。可以避免任何并发问题，但性能十分低下。
如果不是可串行化的话，会出现读取存在的行是10行，但是事务没提交，这个时候锁住的是存在的行，这个时候插入行并提交了的话，就会产生后面读取的行数不对了。出现幻读了。
![img_9.png](Image%2Fimg_9.png)
解决方案就是使用可串行化，把整个表给锁住了。
![img_10.png](Image%2Fimg_10.png)

**m面试题测试**
```text
//1.请简单介绍Spring支持的常用数据库事务传播属性和事务隔离级别？

/**
 * 事务的属性：
 * 	1.★propagation：用来设置事务的传播行为
 * 		事务的传播行为：一个方法运行在了一个开启了事务的方法中时，当前方法是使用原来的事务还是开启一个新的事务
 * 		-Propagation.REQUIRED：默认值，使用原来的事务
 * 		-Propagation.REQUIRES_NEW：将原来的事务挂起，开启一个新的事务
 * 	2.★isolation：用来设置事务的隔离级别
 * 		-Isolation.REPEATABLE_READ：可重复读，MySQL默认的隔离级别
 * 		-Isolation.READ_COMMITTED：读已提交，Oracle默认的隔离级别，开发时通常使用的隔离级别
 */

```
