**JavaSE面试题：自增变量**

- 代码

```java
    public static void main(String[] args) {
        int i=1;
        i=i++;
        int j=i++;
        int k=i + ++i * i++;
        System.out.println("i="+i);
        System.out.println("j="+j);
        System.out.println("k="+k);
    }
```

- 现在，让我们逐行解释这段代码的执行

> **1.** ` int i = 1`;：创建整数变量 i 并将其初始化为1。(i=1;)
>
> **2.** ` i = i++;`：这是一个有争议的表达式。首先，它将 i 的当前值1压栈到一个操作数栈中。然后，它将 i 自增1，这就使得变量i=2了，但右边的操作数栈不是没有后续的逻辑运算了，就会将之前压到操作数栈的1赋值给i。所以，i 的值又变为了1。(i=1;)
> -     如果是`i=++i`呢，就是入栈的时候就会将自增后的变量i压入栈中，变量i2,使得出栈的时候也是为2了。
>
> **3.** ` int j = i++;`：将 i 的当前值1赋给 j，然后将 i 自增1。所以，j 的值是1，而 i 的值变为2。(i=2;j=1)
>
> **4.** `int k = i + ++i * i++;`：这是一个复杂的表达式。首先看右边的表达式，操作数栈会先将i变量入栈；也就是2先入栈，这个时候往右走++i，是将i自增后的数压入栈中，也就是3，然后再看下一个操作数是i++;记住一点的就是，`++i压入栈中是将i自增后压入栈中；i++是将i变量压入栈中；` ，记住这个规则就是，继续压入栈中的数字是3 。所以现在的操作数栈中的数据从栈低到栈顶依次为：2->3->3；按照运算符操作顺序先乘后加，2+3*3=11。

打印结果：

```text
i=4
j=1
k=11
```

### 小结

- 1. 赋值=，最后计算
- 2. =右边的从左到右加载值依次压入操作数栈
- 3. 实际先算哪个，看运算符优先级
- 4. 自增、自减操作都是直接修改变量的值，不经过操作数栈
- 5. 最后的赋值之前，临时结果也是存储在操作数栈中

> 建议:《JVM虚拟机规范》关于指令的部分
